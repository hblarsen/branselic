// automatically generated by Xtext
grammar org.xtext.branselic.ConfiguratorLang with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.itu.dk/configurator/branselic" as branselic

ConfiguratorModel returns branselic::ConfiguratorModel:
	'Features' feature+=Feature (feature+=Feature)* 
	'Rules' ruleset=RuleSet
	;


Feature returns branselic::Feature:
	Name=EString
	':'
	type=[branselic::Type]
	;
	
Operator returns branselic::Operator:
	feature=[branselic::Feature|EString]
	op=OpSymbol
	value=EString
	;

OpSymbol returns ecore::EString:
	('=' | '<' | '>' )
	;


Type returns branselic::Type:
	BoolType | IntType | EnumType;


BoolType returns branselic::Bool:
	{branselic::Bool}
	'bool'
	;

IntType returns branselic::Int:
	{branselic::Int}
	'int'
	;

EnumType returns branselic::Enum:
	{branselic::Enum}
	'['
		(values+=EString ( "," values+=EString)* )?
	']';



RuleSet returns branselic::RuleSet:
	{branselic::RuleSet}
	(rule+=Rule)*
	;



Rule returns branselic::Rule:
	if=BooleanExpression
	'->'
	then=BooleanExpression
	;


BooleanExpression returns branselic::BooleanExpression:
	Const | Atom | Or | Negation | And;


Const returns branselic::Const:
	value=EBoolean
	;

Atom returns branselic::Atom:
	operator=[branselic::Operator]
	;

Or returns branselic::Or:
	'(' booleanexpression+=BooleanExpression ( "or" booleanexpression+=BooleanExpression)* ')' 
	;

Negation returns branselic::Negation:
	'not' booleanexpression=BooleanExpression
	;

And returns branselic::And:
	'(' booleanexpression+=BooleanExpression ( "and" booleanexpression+=BooleanExpression)* ')';


EString returns ecore::EString:
	STRING | ID;

EBoolean returns ecore::EBoolean:
	'true' | 'false';
